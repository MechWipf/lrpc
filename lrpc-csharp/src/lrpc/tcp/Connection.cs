using System;
using System.Net.Sockets;
using lrpc.val;
using lrpc.buf;

namespace lrpc.tcp
{
    /// <summary>
    /// method for calling server by sending data synchronously with TCP
    /// </summary>
    public class Connection : IDisposable
    {
        private Socket socket;

        /// <summary>
        /// connect to the service host
        /// </summary>
        /// <param name="host">server address</param>
        /// <param name="port">server port</param>
        public Connection(String host, int port)
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            socket.Connect(host, port);
        }

        /// <summary>
        /// close connection
        /// </summary>
        public void Dispose()
        {
            socket.Shutdown(SocketShutdown.Both);
            socket.Dispose();
        }

        /// <summary>
        /// call the server method
        /// </summary>
        /// <typeparam name="T">any type can be used here when the server is void</typeparam>
        /// <param name="fun">data generated by Fun.fun</param>
        /// <returns>the data returned by the server is null when there is no return value</returns>
        public T Invoke<T>(ByteQue fun)
        {
            byte[] data = new SendData(fun).ToArray();
            int write = 0;
            while (true)
            {
                write += socket.Send(data, write, data.Length - write, SocketFlags.None);
                if (write >= data.Length)
                {
                    break;
                }
            }
            RecvBuf recv = new RecvBuf();
            byte[] buf = new byte[1024];
            while (true)
            {
                if (recv.Size.HasValue && recv.Size == recv.Len)
                {
                    break;
                }
                int read = socket.Receive(buf);
                if (read > 0)
                {
                    recv.Append(buf, read);
                }
                else
                {
                    Dispose();
                    throw new Exception("remote connection has been disconnected");
                }
            }
            ByteQue ret = recv.ByteQue;
            String msg = ret.Pop<string>();
            if (msg != null)
            {
                throw new Exception(msg);
            }
            if (ret.Len > 0)
            {
                return ret.Pop<T>();
            }
            return default(T);
        }
    }
}
